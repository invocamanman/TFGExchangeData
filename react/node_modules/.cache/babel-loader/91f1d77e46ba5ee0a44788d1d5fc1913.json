{"ast":null,"code":"import _toArray from \"/home/jesus/Escritorio/tfg SC/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"/home/jesus/Escritorio/tfg SC/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/jesus/Escritorio/tfg SC/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/jesus/Escritorio/tfg SC/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jesus/Escritorio/tfg SC/react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _require = require('ethereumjs-util'),\n    toBuffer = _require.toBuffer,\n    keccak256 = _require.keccak256,\n    bufferToHex = _require.bufferToHex;\n\nvar EMPTY_PROOF = [];\n\nvar MerkleTreeBuilder =\n/*#__PURE__*/\nfunction () {\n  function MerkleTreeBuilder(_ref) {\n    var hashDataBlock = _ref.hashDataBlock,\n        hashNodePair = _ref.hashNodePair;\n\n    _classCallCheck(this, MerkleTreeBuilder);\n\n    this._hashDataBlock = hashDataBlock;\n    this._hashNodePair = hashNodePair;\n  }\n\n  _createClass(MerkleTreeBuilder, [{\n    key: \"_build\",\n    value: function _build(nodes) {\n      if (nodes.length === 1) {\n        var _nodes = _slicedToArray(nodes, 1),\n            root = _nodes[0];\n\n        return {\n          root: root,\n          proofs: [EMPTY_PROOF]\n        };\n      } else {\n        var midpoint = Math.pow(2, Math.ceil(Math.log2(nodes.length))) / 2; //coge la potencia de 2 mśa grande como punto medio (o bien si es una pontencia de dos, la mitad) //todo el sentido del mundo pq merkle tree binario\n\n        var subTreeL = this._build(nodes.slice(0, midpoint));\n\n        var subTreeR = this._build(nodes.slice(midpoint)); //reciproco, de manera que devuelve la rrot y la proof de estos\n\n\n        var subRootL = subTreeL.root,\n            subProofsL = subTreeL.proofs;\n        var subRootR = subTreeR.root,\n            subProofsR = subTreeR.proofs;\n\n        var _root = this._hashNodePair(subRootL, subRootR);\n\n        var proofs = [].concat(_toConsumableArray(subProofsL.map(function (subProofL) {\n          return [].concat(_toConsumableArray(subProofL), [subRootR]);\n        })), _toConsumableArray(subProofsR.map(function (subProofR) {\n          return [].concat(_toConsumableArray(subProofR), [subRootL]);\n        })));\n        return {\n          root: _root,\n          proofs: proofs\n        };\n      }\n    }\n  }, {\n    key: \"bufBuild\",\n    value: function bufBuild(dataBlocks) {\n      var _this = this;\n\n      return this._build(dataBlocks.map(function (dataBlock) {\n        return _this._hashDataBlock(dataBlock);\n      }));\n    }\n  }, {\n    key: \"bufVerifyProof\",\n    value: function bufVerifyProof(proof, root, dataBlock) {\n      var _this2 = this;\n\n      var node = this._hashDataBlock(dataBlock);\n\n      return proof.reduce(function (node1, node2) {\n        return _this2._hashNodePair(node1, node2);\n      }, node).equals(root);\n    }\n  }, {\n    key: \"buildMerkleTree\",\n    value: function buildMerkleTree(hexDataBlocks) {\n      var bufDataBlocks = hexDataBlocks.map(toBuffer);\n\n      var _this$bufBuild = this.bufBuild(bufDataBlocks),\n          bufRoot = _this$bufBuild.root,\n          bufProofs = _this$bufBuild.proofs;\n\n      var hexRoot = bufferToHex(bufRoot);\n      var hexProofs = bufProofs.map(function (bufProof) {\n        return bufProof.map(bufferToHex);\n      });\n      return {\n        root: hexRoot,\n        proofs: hexProofs\n      };\n    }\n  }, {\n    key: \"verifyProof\",\n    value: function verifyProof(hexProof, hexRoot, hexDataBlock) {\n      return this.bufVerifyProof(hexProof.map(toBuffer), toBuffer(hexRoot), toBuffer(hexDataBlock));\n    }\n  }]);\n\n  return MerkleTreeBuilder;\n}();\n\nvar PREFIX_00 = toBuffer('0x00');\nvar PREFIX_01 = toBuffer('0x01');\nexport var MerkleTreeLibrary = new MerkleTreeBuilder({\n  hashDataBlock: function hashDataBlock(dataBlock) {\n    return keccak256(Buffer.concat([PREFIX_00, dataBlock])); //para rpevenir posible ataques, un atacante podria poner otros niveles que no fuesen elprimero, por eso todos los nivelesde abajo deben empezar por 00\n  },\n  hashNodePair: function hashNodePair(node1, node2) {\n    return keccak256(Buffer.concat([PREFIX_01].concat(_toConsumableArray([node1, node2].sort(Buffer.compare)))));\n  }\n});\nexport var zip = function zip() {\n  for (var _len = arguments.length, unzippeds = new Array(_len), _key = 0; _key < _len; _key++) {\n    unzippeds[_key] = arguments[_key];\n  }\n\n  return unzippeds.some(function (_ref2) {\n    var length = _ref2.length;\n    return length === 0;\n  }) ? [] : [unzippeds.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        head = _ref4[0];\n\n    return head;\n  })].concat(_toConsumableArray(zip.apply(void 0, _toConsumableArray(unzippeds.map(function (_ref5) {\n    var _ref6 = _toArray(_ref5),\n        tail = _ref6.slice(1);\n\n    return tail;\n  })))));\n};\nexport var genIntSequence = function genIntSequence(n) {\n  var result = new Array(n);\n\n  for (var i = 0; i < n; i++) {\n    result[i] = i;\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/jesus/Escritorio/tfg SC/react/src/resources/merkletreelib.js"],"names":["require","toBuffer","keccak256","bufferToHex","EMPTY_PROOF","MerkleTreeBuilder","hashDataBlock","hashNodePair","_hashDataBlock","_hashNodePair","nodes","length","root","proofs","midpoint","Math","ceil","log2","subTreeL","_build","slice","subTreeR","subRootL","subProofsL","subRootR","subProofsR","map","subProofL","subProofR","dataBlocks","dataBlock","proof","node","reduce","node1","node2","equals","hexDataBlocks","bufDataBlocks","bufBuild","bufRoot","bufProofs","hexRoot","hexProofs","bufProof","hexProof","hexDataBlock","bufVerifyProof","PREFIX_00","PREFIX_01","MerkleTreeLibrary","Buffer","concat","sort","compare","zip","unzippeds","some","head","tail","genIntSequence","n","result","Array","i"],"mappings":"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","sourcesContent":["const { toBuffer, keccak256, bufferToHex } = require('ethereumjs-util');\n\nconst EMPTY_PROOF = [];\n\nclass MerkleTreeBuilder {\n  constructor ({ hashDataBlock, hashNodePair }) {\n    this._hashDataBlock = hashDataBlock;\n    this._hashNodePair = hashNodePair;\n  }\n\n  _build (nodes) {\n    if (nodes.length === 1) {\n      const [root] = nodes;\n      return { root, proofs: [EMPTY_PROOF] };\n    } else {\n      const midpoint = 2 ** Math.ceil(Math.log2(nodes.length)) / 2; //coge la potencia de 2 mśa grande como punto medio (o bien si es una pontencia de dos, la mitad) //todo el sentido del mundo pq merkle tree binario\n      const subTreeL = this._build(nodes.slice(0, midpoint));\n      const subTreeR = this._build(nodes.slice(midpoint));//reciproco, de manera que devuelve la rrot y la proof de estos\n      const { root: subRootL, proofs: subProofsL } = subTreeL;\n      const { root: subRootR, proofs: subProofsR } = subTreeR;\n      const root = this._hashNodePair(subRootL, subRootR);\n      const proofs = [\n        ...subProofsL.map(subProofL => [...subProofL, subRootR]),\n        ...subProofsR.map(subProofR => [...subProofR, subRootL]),\n      ];\n      return { root, proofs };\n    }\n  }\n\n  bufBuild (dataBlocks) {\n    return this._build(dataBlocks.map(dataBlock => this._hashDataBlock(dataBlock)));\n  }\n\n  bufVerifyProof (proof, root, dataBlock) {\n    const node = this._hashDataBlock(dataBlock);\n    return proof.reduce((node1, node2) => this._hashNodePair(node1, node2), node).equals(root);\n  }\n\n  buildMerkleTree (hexDataBlocks) {\n    const bufDataBlocks = hexDataBlocks.map(toBuffer);\n    const { root: bufRoot, proofs: bufProofs } = this.bufBuild(bufDataBlocks);\n    const hexRoot = bufferToHex(bufRoot);\n    const hexProofs = bufProofs.map(bufProof => bufProof.map(bufferToHex));\n    return { root: hexRoot, proofs: hexProofs };\n  }\n\n  verifyProof (hexProof, hexRoot, hexDataBlock) {\n    return this.bufVerifyProof(hexProof.map(toBuffer), toBuffer(hexRoot), toBuffer(hexDataBlock));\n  }\n}\n\nconst PREFIX_00 = toBuffer('0x00');\nconst PREFIX_01 = toBuffer('0x01');\n\nexport const MerkleTreeLibrary = new MerkleTreeBuilder({\n  hashDataBlock (dataBlock) {\n    return keccak256(Buffer.concat([PREFIX_00, dataBlock]));//para rpevenir posible ataques, un atacante podria poner otros niveles que no fuesen elprimero, por eso todos los nivelesde abajo deben empezar por 00\n  },\n  hashNodePair (node1, node2) {\n    return keccak256(Buffer.concat([PREFIX_01, ...[node1, node2].sort(Buffer.compare)]));\n  },\n});\n\n\nexport const zip = (...unzippeds) =>\n  unzippeds.some(({ length }) => length === 0)\n    ? []\n    : [unzippeds.map(([head]) => head), ...zip(...unzippeds.map(([, ...tail]) => tail))];\n\nexport const genIntSequence = n => {\n  const result = new Array(n);\n  for (let i = 0; i < n; i++) {\n    result[i] = i;\n  }\n  return result;\n};\n\n"]},"metadata":{},"sourceType":"module"}